// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace Configurator
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

         public ParseTree Parse(string input)
        {
            return Parse(input, "", new ParseTree());
        }

        public ParseTree Parse(string input, string fileName)
        {
            return Parse(input, fileName, new ParseTree());
        }

        public ParseTree Parse(string input, string fileName, ParseTree tree)
        {
            scanner.Init(input, fileName);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent) // NonTerminalSymbol: Start
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.NSOPEN, TokenType.NAME, TokenType.TAGOPEN, TokenType.CONTENTTAGOPEN, TokenType.LISTOPEN); // ZeroOrMore Rule
            while (tok.Type == TokenType.NSOPEN
                || tok.Type == TokenType.NAME
                || tok.Type == TokenType.TAGOPEN
                || tok.Type == TokenType.CONTENTTAGOPEN
                || tok.Type == TokenType.LISTOPEN)
            {
                tok = scanner.LookAhead(TokenType.NSOPEN, TokenType.NAME, TokenType.TAGOPEN, TokenType.CONTENTTAGOPEN, TokenType.LISTOPEN); // Choice Rule
                switch (tok.Type)
                { // Choice Rule
                    case TokenType.NSOPEN:
                        ParseNamespace(node); // NonTerminal Rule: Namespace
                        break;
                    case TokenType.NAME:
                    case TokenType.TAGOPEN:
                    case TokenType.CONTENTTAGOPEN:
                    case TokenType.LISTOPEN:
                        ParseDeclaration(node); // NonTerminal Rule: Declaration
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                        break;
                } // Choice Rule
            tok = scanner.LookAhead(TokenType.NSOPEN, TokenType.NAME, TokenType.TAGOPEN, TokenType.CONTENTTAGOPEN, TokenType.LISTOPEN); // ZeroOrMore Rule
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOF); // Terminal Rule: EOF
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Start

        private void ParseNamespace(ParseNode parent) // NonTerminalSymbol: Namespace
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Namespace), "Namespace");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseNamespaceBegin(node); // NonTerminal Rule: NamespaceBegin

             // Concat Rule
            tok = scanner.LookAhead(TokenType.NAME, TokenType.TAGOPEN, TokenType.CONTENTTAGOPEN, TokenType.LISTOPEN); // ZeroOrMore Rule
            while (tok.Type == TokenType.NAME
                || tok.Type == TokenType.TAGOPEN
                || tok.Type == TokenType.CONTENTTAGOPEN
                || tok.Type == TokenType.LISTOPEN)
            {
                ParseDeclaration(node); // NonTerminal Rule: Declaration
            tok = scanner.LookAhead(TokenType.NAME, TokenType.TAGOPEN, TokenType.CONTENTTAGOPEN, TokenType.LISTOPEN); // ZeroOrMore Rule
            }

             // Concat Rule
            ParseNamespaceEnd(node); // NonTerminal Rule: NamespaceEnd

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Namespace

        private void ParseDeclaration(ParseNode parent) // NonTerminalSymbol: Declaration
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Declaration), "Declaration");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.NAME, TokenType.TAGOPEN, TokenType.CONTENTTAGOPEN, TokenType.LISTOPEN); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.NAME:
                    ParseSimpleDeclaration(node); // NonTerminal Rule: SimpleDeclaration
                    break;
                case TokenType.TAGOPEN:
                    ParseComplexDeclaration(node); // NonTerminal Rule: ComplexDeclaration
                    break;
                case TokenType.CONTENTTAGOPEN:
                    ParseMultiLineDeclaration(node); // NonTerminal Rule: MultiLineDeclaration
                    break;
                case TokenType.LISTOPEN:
                    ParseListDeclaration(node); // NonTerminal Rule: ListDeclaration
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Declaration

        private void ParseSimpleDeclaration(ParseNode parent) // NonTerminalSymbol: SimpleDeclaration
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.SimpleDeclaration), "SimpleDeclaration");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NAME) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EQUAL); // Terminal Rule: EQUAL
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EQUAL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUAL.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.SINGLELINECONTENT, TokenType.QUOTEDCONTENT); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.SINGLELINECONTENT:
                    tok = scanner.Scan(TokenType.SINGLELINECONTENT); // Terminal Rule: SINGLELINECONTENT
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SINGLELINECONTENT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLELINECONTENT.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.QUOTEDCONTENT:
                    tok = scanner.Scan(TokenType.QUOTEDCONTENT); // Terminal Rule: QUOTEDCONTENT
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.QUOTEDCONTENT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.QUOTEDCONTENT.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            } // Choice Rule

             // Concat Rule
            tok = scanner.Scan(TokenType.ENDLINE); // Terminal Rule: ENDLINE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ENDLINE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ENDLINE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: SimpleDeclaration

        private void ParseComplexDeclaration(ParseNode parent) // NonTerminalSymbol: ComplexDeclaration
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ComplexDeclaration), "ComplexDeclaration");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseTagBegin(node); // NonTerminal Rule: TagBegin

             // Concat Rule
            tok = scanner.LookAhead(TokenType.NAME, TokenType.TAGOPEN, TokenType.CONTENTTAGOPEN, TokenType.LISTOPEN); // ZeroOrMore Rule
            while (tok.Type == TokenType.NAME
                || tok.Type == TokenType.TAGOPEN
                || tok.Type == TokenType.CONTENTTAGOPEN
                || tok.Type == TokenType.LISTOPEN)
            {
                ParseDeclaration(node); // NonTerminal Rule: Declaration
            tok = scanner.LookAhead(TokenType.NAME, TokenType.TAGOPEN, TokenType.CONTENTTAGOPEN, TokenType.LISTOPEN); // ZeroOrMore Rule
            }

             // Concat Rule
            ParseTagEnd(node); // NonTerminal Rule: TagEnd

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ComplexDeclaration

        private void ParseMultiLineDeclaration(ParseNode parent) // NonTerminalSymbol: MultiLineDeclaration
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MultiLineDeclaration), "MultiLineDeclaration");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseContentTagBegin(node); // NonTerminal Rule: ContentTagBegin

             // Concat Rule
            tok = scanner.Scan(TokenType.MULTILINECONTENT); // Terminal Rule: MULTILINECONTENT
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.MULTILINECONTENT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULTILINECONTENT.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseContentTagEnd(node); // NonTerminal Rule: ContentTagEnd

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: MultiLineDeclaration

        private void ParseListDeclaration(ParseNode parent) // NonTerminalSymbol: ListDeclaration
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ListDeclaration), "ListDeclaration");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseListTagBegin(node); // NonTerminal Rule: ListTagBegin

             // Concat Rule
            tok = scanner.LookAhead(TokenType.CONTENTTAGOPEN, TokenType.SINGLELINEITEM, TokenType.QUOTEDITEM); // ZeroOrMore Rule
            while (tok.Type == TokenType.CONTENTTAGOPEN
                || tok.Type == TokenType.SINGLELINEITEM
                || tok.Type == TokenType.QUOTEDITEM)
            {
                tok = scanner.LookAhead(TokenType.CONTENTTAGOPEN, TokenType.SINGLELINEITEM, TokenType.QUOTEDITEM); // Choice Rule
                switch (tok.Type)
                { // Choice Rule
                    case TokenType.CONTENTTAGOPEN:
                        ParseMultiLineDeclaration(node); // NonTerminal Rule: MultiLineDeclaration
                        break;
                    case TokenType.SINGLELINEITEM:
                    case TokenType.QUOTEDITEM:

                         // Concat Rule
                        tok = scanner.LookAhead(TokenType.SINGLELINEITEM, TokenType.QUOTEDITEM); // Choice Rule
                        switch (tok.Type)
                        { // Choice Rule
                            case TokenType.SINGLELINEITEM:
                                tok = scanner.Scan(TokenType.SINGLELINEITEM); // Terminal Rule: SINGLELINEITEM
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.SINGLELINEITEM) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLELINEITEM.ToString(), 0x1001, tok));
                                    return;
                                }
                                break;
                            case TokenType.QUOTEDITEM:
                                tok = scanner.Scan(TokenType.QUOTEDITEM); // Terminal Rule: QUOTEDITEM
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.QUOTEDITEM) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.QUOTEDITEM.ToString(), 0x1001, tok));
                                    return;
                                }
                                break;
                            default:
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                                break;
                        } // Choice Rule

                         // Concat Rule
                        tok = scanner.Scan(TokenType.ENDLINE); // Terminal Rule: ENDLINE
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.ENDLINE) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ENDLINE.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                        break;
                } // Choice Rule
            tok = scanner.LookAhead(TokenType.CONTENTTAGOPEN, TokenType.SINGLELINEITEM, TokenType.QUOTEDITEM); // ZeroOrMore Rule
            }

             // Concat Rule
            ParseListTagEnd(node); // NonTerminal Rule: ListTagEnd

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ListDeclaration

        private void ParseNamespaceBegin(ParseNode parent) // NonTerminalSymbol: NamespaceBegin
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.NamespaceBegin), "NamespaceBegin");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.NSOPEN); // Terminal Rule: NSOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NSOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NSOPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NAME) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TAGCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: NamespaceBegin

        private void ParseNamespaceEnd(ParseNode parent) // NonTerminalSymbol: NamespaceEnd
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.NamespaceEnd), "NamespaceEnd");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.NSCLOSE); // Terminal Rule: NSCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NSCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NSCLOSE.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NAME) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TAGCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: NamespaceEnd

        private void ParseTagBegin(ParseNode parent) // NonTerminalSymbol: TagBegin
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.TagBegin), "TagBegin");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.TAGOPEN); // Terminal Rule: TAGOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TAGOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGOPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NAME) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TAGCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: TagBegin

        private void ParseTagEnd(ParseNode parent) // NonTerminalSymbol: TagEnd
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.TagEnd), "TagEnd");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.TAGOPENALT); // Terminal Rule: TAGOPENALT
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TAGOPENALT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGOPENALT.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NAME) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TAGCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: TagEnd

        private void ParseContentTagBegin(ParseNode parent) // NonTerminalSymbol: ContentTagBegin
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ContentTagBegin), "ContentTagBegin");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.CONTENTTAGOPEN); // Terminal Rule: CONTENTTAGOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CONTENTTAGOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CONTENTTAGOPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NAME) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TAGCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ContentTagBegin

        private void ParseContentTagEnd(ParseNode parent) // NonTerminalSymbol: ContentTagEnd
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ContentTagEnd), "ContentTagEnd");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.CONTENTTAGOPENALT); // Terminal Rule: CONTENTTAGOPENALT
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CONTENTTAGOPENALT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CONTENTTAGOPENALT.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NAME) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TAGCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ContentTagEnd

        private void ParseListTagBegin(ParseNode parent) // NonTerminalSymbol: ListTagBegin
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ListTagBegin), "ListTagBegin");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.LISTOPEN); // Terminal Rule: LISTOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LISTOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LISTOPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NAME) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TAGCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ListTagBegin

        private void ParseListTagEnd(ParseNode parent) // NonTerminalSymbol: ListTagEnd
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ListTagEnd), "ListTagEnd");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.LISTOPENALT); // Terminal Rule: LISTOPENALT
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LISTOPENALT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LISTOPENALT.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NAME) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TAGCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ListTagEnd


    }

    #endregion Parser
}
