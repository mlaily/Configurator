// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace Configurator.Parser
{
	#region Parser

	public partial class Parser
	{
		private Scanner scanner;
		private ParseTree tree;

		public Parser(Scanner scanner)
		{
			this.scanner = scanner;
		}

		public ParseTree Parse(string input)
		{
			return Parse(input, "", new ParseTree());
		}

		public ParseTree Parse(string input, string fileName)
		{
			return Parse(input, fileName, new ParseTree());
		}

		public ParseTree Parse(string input, string fileName, ParseTree tree)
		{
			scanner.Init(input, fileName);

			this.tree = tree;
			ParseStart(tree);
			tree.Skipped = scanner.Skipped;

			return tree;
		}

		private void ParseStart(ParseNode parent) // NonTerminalSymbol: Start
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
			parent.Nodes.Add(node);


			// Concat Rule
			tok = scanner.LookAhead(TokenType.NSOPEN, TokenType.NAME, TokenType.TAGOPEN, TokenType.MULTILINETAGOPEN, TokenType.LISTOPEN); // ZeroOrMore Rule
			while (tok.Type == TokenType.NSOPEN
				|| tok.Type == TokenType.NAME
				|| tok.Type == TokenType.TAGOPEN
				|| tok.Type == TokenType.MULTILINETAGOPEN
				|| tok.Type == TokenType.LISTOPEN)
			{
				tok = scanner.LookAhead(TokenType.NSOPEN, TokenType.NAME, TokenType.TAGOPEN, TokenType.MULTILINETAGOPEN, TokenType.LISTOPEN); // Choice Rule
				switch (tok.Type)
				{ // Choice Rule
					case TokenType.NSOPEN:
						ParseNamespace(node); // NonTerminal Rule: Namespace
						break;
					case TokenType.NAME:
					case TokenType.TAGOPEN:
					case TokenType.MULTILINETAGOPEN:
					case TokenType.LISTOPEN:
						ParseDeclaration(node); // NonTerminal Rule: Declaration
						break;
					default:
						tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
						break;
				} // Choice Rule
				tok = scanner.LookAhead(TokenType.NSOPEN, TokenType.NAME, TokenType.TAGOPEN, TokenType.MULTILINETAGOPEN, TokenType.LISTOPEN); // ZeroOrMore Rule
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.EOF); // Terminal Rule: EOF
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.EOF)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: Start

		private void ParseNamespace(ParseNode parent) // NonTerminalSymbol: Namespace
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Namespace), "Namespace");
			parent.Nodes.Add(node);


			// Concat Rule
			ParseNamespaceBegin(node); // NonTerminal Rule: NamespaceBegin

			// Concat Rule
			tok = scanner.LookAhead(TokenType.NAME, TokenType.TAGOPEN, TokenType.MULTILINETAGOPEN, TokenType.LISTOPEN); // ZeroOrMore Rule
			while (tok.Type == TokenType.NAME
				|| tok.Type == TokenType.TAGOPEN
				|| tok.Type == TokenType.MULTILINETAGOPEN
				|| tok.Type == TokenType.LISTOPEN)
			{
				ParseDeclaration(node); // NonTerminal Rule: Declaration
				tok = scanner.LookAhead(TokenType.NAME, TokenType.TAGOPEN, TokenType.MULTILINETAGOPEN, TokenType.LISTOPEN); // ZeroOrMore Rule
			}

			// Concat Rule
			ParseNamespaceEnd(node); // NonTerminal Rule: NamespaceEnd

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: Namespace

		private void ParseDeclaration(ParseNode parent) // NonTerminalSymbol: Declaration
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Declaration), "Declaration");
			parent.Nodes.Add(node);

			tok = scanner.LookAhead(TokenType.NAME, TokenType.TAGOPEN, TokenType.MULTILINETAGOPEN, TokenType.LISTOPEN); // Choice Rule
			switch (tok.Type)
			{ // Choice Rule
				case TokenType.NAME:
					ParseSimpleDeclaration(node); // NonTerminal Rule: SimpleDeclaration
					break;
				case TokenType.TAGOPEN:
					ParseComplexDeclaration(node); // NonTerminal Rule: ComplexDeclaration
					break;
				case TokenType.MULTILINETAGOPEN:
					ParseMultiLineDeclaration(node); // NonTerminal Rule: MultiLineDeclaration
					break;
				case TokenType.LISTOPEN:
					ParseListDeclaration(node); // NonTerminal Rule: ListDeclaration
					break;
				default:
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
					break;
			} // Choice Rule

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: Declaration

		private void ParseSimpleDeclaration(ParseNode parent) // NonTerminalSymbol: SimpleDeclaration
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.SimpleDeclaration), "SimpleDeclaration");
			parent.Nodes.Add(node);


			// Concat Rule
			tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.NAME)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.EQUAL); // Terminal Rule: EQUAL
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.EQUAL)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUAL.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.LookAhead(TokenType.SINGLELINECONTENT, TokenType.QUOTEDCONTENT); // Choice Rule
			switch (tok.Type)
			{ // Choice Rule
				case TokenType.SINGLELINECONTENT:
					tok = scanner.Scan(TokenType.SINGLELINECONTENT); // Terminal Rule: SINGLELINECONTENT
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.SINGLELINECONTENT)
					{
						tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLELINECONTENT.ToString(), 0x1001, tok));
						return;
					}
					break;
				case TokenType.QUOTEDCONTENT:
					tok = scanner.Scan(TokenType.QUOTEDCONTENT); // Terminal Rule: QUOTEDCONTENT
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.QUOTEDCONTENT)
					{
						tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.QUOTEDCONTENT.ToString(), 0x1001, tok));
						return;
					}
					break;
				default:
					tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
					break;
			} // Choice Rule

			// Concat Rule
			tok = scanner.Scan(TokenType.ENDLINE); // Terminal Rule: ENDLINE
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.ENDLINE)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ENDLINE.ToString(), 0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: SimpleDeclaration

		private void ParseComplexDeclaration(ParseNode parent) // NonTerminalSymbol: ComplexDeclaration
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ComplexDeclaration), "ComplexDeclaration");
			parent.Nodes.Add(node);


			// Concat Rule
			ParseTagBegin(node); // NonTerminal Rule: TagBegin

			// Concat Rule
			tok = scanner.LookAhead(TokenType.NAME, TokenType.TAGOPEN, TokenType.MULTILINETAGOPEN, TokenType.LISTOPEN); // ZeroOrMore Rule
			while (tok.Type == TokenType.NAME
				|| tok.Type == TokenType.TAGOPEN
				|| tok.Type == TokenType.MULTILINETAGOPEN
				|| tok.Type == TokenType.LISTOPEN)
			{
				ParseDeclaration(node); // NonTerminal Rule: Declaration
				tok = scanner.LookAhead(TokenType.NAME, TokenType.TAGOPEN, TokenType.MULTILINETAGOPEN, TokenType.LISTOPEN); // ZeroOrMore Rule
			}

			// Concat Rule
			ParseTagEnd(node); // NonTerminal Rule: TagEnd

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: ComplexDeclaration

		private void ParseMultiLineDeclaration(ParseNode parent) // NonTerminalSymbol: MultiLineDeclaration
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MultiLineDeclaration), "MultiLineDeclaration");
			parent.Nodes.Add(node);


			// Concat Rule
			ParseMultiLineTagBegin(node); // NonTerminal Rule: MultiLineTagBegin

			// Concat Rule
			tok = scanner.Scan(TokenType.MULTILINECONTENT); // Terminal Rule: MULTILINECONTENT
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.MULTILINECONTENT)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULTILINECONTENT.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			ParseMultiLineTagEnd(node); // NonTerminal Rule: MultiLineTagEnd

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: MultiLineDeclaration

		private void ParseMultiLineItem(ParseNode parent) // NonTerminalSymbol: MultiLineItem
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MultiLineItem), "MultiLineItem");
			parent.Nodes.Add(node);


			// Concat Rule
			ParseMultiLineListItemBegin(node); // NonTerminal Rule: MultiLineListItemBegin

			// Concat Rule
			tok = scanner.Scan(TokenType.MULTILINECONTENT); // Terminal Rule: MULTILINECONTENT
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.MULTILINECONTENT)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULTILINECONTENT.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			ParseMultiLineListItemEnd(node); // NonTerminal Rule: MultiLineListItemEnd

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: MultiLineItem

		private void ParseListDeclaration(ParseNode parent) // NonTerminalSymbol: ListDeclaration
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ListDeclaration), "ListDeclaration");
			parent.Nodes.Add(node);


			// Concat Rule
			ParseListTagBegin(node); // NonTerminal Rule: ListTagBegin

			// Concat Rule
			tok = scanner.LookAhead(TokenType.MULTILINETAGOPEN, TokenType.SIMPLEITEM, TokenType.QUOTEDITEM); // ZeroOrMore Rule
			while (tok.Type == TokenType.MULTILINETAGOPEN
				|| tok.Type == TokenType.SIMPLEITEM
				|| tok.Type == TokenType.QUOTEDITEM)
			{
				tok = scanner.LookAhead(TokenType.MULTILINETAGOPEN, TokenType.SIMPLEITEM, TokenType.QUOTEDITEM); // Choice Rule
				switch (tok.Type)
				{ // Choice Rule
					case TokenType.MULTILINETAGOPEN:
						ParseMultiLineItem(node); // NonTerminal Rule: MultiLineItem
						break;
					case TokenType.SIMPLEITEM:
					case TokenType.QUOTEDITEM:
						tok = scanner.LookAhead(TokenType.SIMPLEITEM, TokenType.QUOTEDITEM); // Choice Rule
						switch (tok.Type)
						{ // Choice Rule
							case TokenType.SIMPLEITEM:
								tok = scanner.Scan(TokenType.SIMPLEITEM); // Terminal Rule: SIMPLEITEM
								n = node.CreateNode(tok, tok.ToString());
								node.Token.UpdateRange(tok);
								node.Nodes.Add(n);
								if (tok.Type != TokenType.SIMPLEITEM)
								{
									tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SIMPLEITEM.ToString(), 0x1001, tok));
									return;
								}
								break;
							case TokenType.QUOTEDITEM:
								tok = scanner.Scan(TokenType.QUOTEDITEM); // Terminal Rule: QUOTEDITEM
								n = node.CreateNode(tok, tok.ToString());
								node.Token.UpdateRange(tok);
								node.Nodes.Add(n);
								if (tok.Type != TokenType.QUOTEDITEM)
								{
									tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.QUOTEDITEM.ToString(), 0x1001, tok));
									return;
								}
								break;
							default:
								tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
								break;
						} // Choice Rule
						break;
					default:
						tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
						break;
				} // Choice Rule
				tok = scanner.LookAhead(TokenType.MULTILINETAGOPEN, TokenType.SIMPLEITEM, TokenType.QUOTEDITEM); // ZeroOrMore Rule
			}

			// Concat Rule
			ParseListTagEnd(node); // NonTerminal Rule: ListTagEnd

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: ListDeclaration

		private void ParseNamespaceBegin(ParseNode parent) // NonTerminalSymbol: NamespaceBegin
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.NamespaceBegin), "NamespaceBegin");
			parent.Nodes.Add(node);


			// Concat Rule
			tok = scanner.Scan(TokenType.NSOPEN); // Terminal Rule: NSOPEN
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.NSOPEN)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NSOPEN.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.NAME)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.TAGCLOSE)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: NamespaceBegin

		private void ParseNamespaceEnd(ParseNode parent) // NonTerminalSymbol: NamespaceEnd
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.NamespaceEnd), "NamespaceEnd");
			parent.Nodes.Add(node);


			// Concat Rule
			tok = scanner.Scan(TokenType.NSCLOSE); // Terminal Rule: NSCLOSE
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.NSCLOSE)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NSCLOSE.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.NAME)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.TAGCLOSE)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: NamespaceEnd

		private void ParseTagBegin(ParseNode parent) // NonTerminalSymbol: TagBegin
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.TagBegin), "TagBegin");
			parent.Nodes.Add(node);


			// Concat Rule
			tok = scanner.Scan(TokenType.TAGOPEN); // Terminal Rule: TAGOPEN
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.TAGOPEN)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGOPEN.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.NAME)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.TAGCLOSE)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: TagBegin

		private void ParseTagEnd(ParseNode parent) // NonTerminalSymbol: TagEnd
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.TagEnd), "TagEnd");
			parent.Nodes.Add(node);


			// Concat Rule
			tok = scanner.Scan(TokenType.TAGOPENALT); // Terminal Rule: TAGOPENALT
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.TAGOPENALT)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGOPENALT.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.NAME)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.TAGCLOSE)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: TagEnd

		private void ParseMultiLineTagBegin(ParseNode parent) // NonTerminalSymbol: MultiLineTagBegin
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MultiLineTagBegin), "MultiLineTagBegin");
			parent.Nodes.Add(node);


			// Concat Rule
			tok = scanner.Scan(TokenType.MULTILINETAGOPEN); // Terminal Rule: MULTILINETAGOPEN
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.MULTILINETAGOPEN)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULTILINETAGOPEN.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.NAME)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.TAGCLOSE)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: MultiLineTagBegin

		private void ParseMultiLineTagEnd(ParseNode parent) // NonTerminalSymbol: MultiLineTagEnd
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MultiLineTagEnd), "MultiLineTagEnd");
			parent.Nodes.Add(node);


			// Concat Rule
			tok = scanner.Scan(TokenType.MULTILINETAGOPENALT); // Terminal Rule: MULTILINETAGOPENALT
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.MULTILINETAGOPENALT)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULTILINETAGOPENALT.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.NAME)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.TAGCLOSE)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: MultiLineTagEnd

		private void ParseMultiLineListItemBegin(ParseNode parent) // NonTerminalSymbol: MultiLineListItemBegin
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MultiLineListItemBegin), "MultiLineListItemBegin");
			parent.Nodes.Add(node);


			// Concat Rule
			tok = scanner.Scan(TokenType.MULTILINETAGOPEN); // Terminal Rule: MULTILINETAGOPEN
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.MULTILINETAGOPEN)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULTILINETAGOPEN.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.TAGCLOSE)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: MultiLineListItemBegin

		private void ParseMultiLineListItemEnd(ParseNode parent) // NonTerminalSymbol: MultiLineListItemEnd
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MultiLineListItemEnd), "MultiLineListItemEnd");
			parent.Nodes.Add(node);


			// Concat Rule
			tok = scanner.Scan(TokenType.MULTILINETAGOPENALT); // Terminal Rule: MULTILINETAGOPENALT
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.MULTILINETAGOPENALT)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULTILINETAGOPENALT.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.TAGCLOSE)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: MultiLineListItemEnd

		private void ParseListTagBegin(ParseNode parent) // NonTerminalSymbol: ListTagBegin
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ListTagBegin), "ListTagBegin");
			parent.Nodes.Add(node);


			// Concat Rule
			tok = scanner.Scan(TokenType.LISTOPEN); // Terminal Rule: LISTOPEN
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.LISTOPEN)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LISTOPEN.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.NAME)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.TAGCLOSE)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: ListTagBegin

		private void ParseListTagEnd(ParseNode parent) // NonTerminalSymbol: ListTagEnd
		{
			Token tok;
#pragma warning disable 0168 //Suppress "The variable 'n' is declared but never used" warning.
			ParseNode n;
#pragma warning restore 0168
			ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ListTagEnd), "ListTagEnd");
			parent.Nodes.Add(node);


			// Concat Rule
			tok = scanner.Scan(TokenType.LISTOPENALT); // Terminal Rule: LISTOPENALT
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.LISTOPENALT)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LISTOPENALT.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.NAME); // Terminal Rule: NAME
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.NAME)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAME.ToString(), 0x1001, tok));
				return;
			}

			// Concat Rule
			tok = scanner.Scan(TokenType.TAGCLOSE); // Terminal Rule: TAGCLOSE
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.TAGCLOSE)
			{
				tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAGCLOSE.ToString(), 0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		} // NonTerminalSymbol: ListTagEnd


	}

	#endregion Parser
}
